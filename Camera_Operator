from Operation import *
from copy import deepcopy
import cv2
import numpy as np

left_clicked = False
mouse_drawing_rect_coords = []

def handle_mouse_event(event, x, y, flags, param):
    global left_clicked
    global mouse_drawing_rect_coords

    if (left_clicked):
        '''User is drawing case, so new end is taken'''
        if (len(mouse_drawing_rect_coords) > 2):
            mouse_drawing_rect_coords = []
        if (len(mouse_drawing_rect_coords) > 1):
            del (mouse_drawing_rect_coords[-1])
        mouse_drawing_rect_coords.append((x, y))

    if (event == cv2.EVENT_LBUTTONDOWN and not left_clicked):
        '''User just clicked case - starting to draw'''
        mouse_drawing_rect_coords.append((x, y))
        left_clicked = True
    elif (event == cv2.EVENT_LBUTTONUP):
        '''User stopped drawing case, so area is left as it is'''
        if (len(mouse_drawing_rect_coords) == 2):
            del (mouse_drawing_rect_coords[-1])
        mouse_drawing_rect_coords.append((x, y))
        left_clicked = False

class Camera_operator:


    def __init__(self):
        '''Global variable, when leave is true, program ends'''
        self.leave = False

        '''This attribute stores current user decision'''
        self.status = None

        '''This attribute shows if observer took status'''
        self.status_delivered = True

    def get_status(self):
        '''Function used by observer to get current user decision'''
        self.status_delivered = True
        return self.status


    def get_cropped_image(self,image):
        '''if the area in which hand recognition maus take place was specified, this function prints cropped image'''
        global mouse_drawing_rect_coords
        global left_clicked

        if ( len(mouse_drawing_rect_coords) == 2):

            x_down = mouse_drawing_rect_coords[0][0]
            x_top = mouse_drawing_rect_coords[1][0]
            y_down = mouse_drawing_rect_coords[0][1]
            y_top = mouse_drawing_rect_coords[1][1]

            '''Below bounds control:'''
            if ( x_down < 0 ):
                x_down = 0
            if ( x_top < 0 ):
                x_top = 0
            if ( y_down < 0 ):
                y_down = 0
            if ( y_top < 0 ):
                y_top = 0

            """Checking if given bounds are not swapped(for example x_top is lower than x_down):"""
            if ( x_down > x_top ):
                x_down , x_top = x_top , x_down
            if ( y_down > y_top ):
                y_down , y_top = y_top , y_down


            cropped_image = image[y_down : y_top, x_down : x_top ]
            if ( x_down != x_top and y_down != y_top ):
                return cropped_image
            else:
                return None
        return None
    def operate_cropped_file(self,image):

        if (image is not None):

            contours, hierarchy = cv2.findContours(image, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

            if ( len(contours) < 1 ):
                '''No contours found - propably hand is out of area'''
                return None

            conture_max = max(contours, key=lambda x: cv2.contourArea(x))

            x, y, w, h = cv2.boundingRect(conture_max)
            cv2.rectangle(image, (x, y), (x + w, y + h), (255, 255, 0), 0)

            hull = cv2.convexHull(conture_max)

            drawing = np.zeros(image.shape,np.uint8)
            cv2.drawContours(drawing, [conture_max], 0, (200,160 ,130 ), 0)
            cv2.drawContours(drawing, [hull], 0, (200,160 ,130 ), 0)

            hull = cv2.convexHull(conture_max, returnPoints=False)
            defects = cv2.convexityDefects(conture_max, hull)
            count_defects = 0

            if ( defects is None ):
                return None

            for i in range(defects.shape[0]):
                s, e, f, d = defects[i, 0]

                start = tuple(conture_max[s][0])
                end = tuple(conture_max[e][0])
                far = tuple(conture_max[f][0])

                a = np.sqrt((end[0] - start[0]) ** 2 + (end[1] - start[1]) ** 2)
                b = np.sqrt((far[0] - start[0]) ** 2 + (far[1] - start[1]) ** 2)
                c = np.sqrt((end[0] - far[0]) ** 2 + (end[1] - far[1]) ** 2)

                angle = np.arccos((b ** 2 + c ** 2 - a ** 2) / (2 * b * c)) * 57

                if angle <= 90:
                    count_defects += 1
                    cv2.circle(image, far, 1, [200,160 ,130], -1)

                cv2.line(image, start, end, [200,160 ,130], 2)

            self.status_delivered = False
            if( count_defects == 0 ):
                self.status = Operation.NOFINGERS
            elif ( count_defects == 1):
                self.status = Operation.ONEFINGER
            elif ( count_defects == 2):
                self.status = Operation.TWOFINGERS
            elif ( count_defects == 3):
                self.status = Operation.THREEFINGERS
            elif ( count_defects == 4):
                self.status = Operation.FOURFINGERS
            elif ( count_defects == 5):
                self.status = Operation.FIVEFINGERS
            else:
                '''No gesture recognized'''
                self.status_delivered = True
            '''debug:'''
            cv2.imshow("cr",image)

    def start(self):
        global mouse_drawing_rect_coords
        global left_clicked



        capture = cv2.VideoCapture(0, cv2.CAP_DSHOW)


        key_pressed = 'q'

        base_thresh_val = 59
        base_gaussian_val = 5
        base_med_val = 11
        printing_label = True

        thresh1 = None
        '''variable used to assign for variable prev_image'''

        while( capture.isOpened() and (not self.leave) ):

            prev_image = deepcopy(thresh1)

            '''Reading image:'''
            ret, frame = capture.read()
            if ( ret == False):
                print("Failed to catch")
            cv2.setMouseCallback('Current frame', handle_mouse_event)

            gray = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)

            blur = cv2.GaussianBlur(gray,(base_gaussian_val,base_gaussian_val),0)

            med = cv2.medianBlur(blur,base_med_val)

            ret, thresh1 = cv2.threshold(med, base_thresh_val , 255, cv2.THRESH_BINARY_INV )

            cropped_image = self.get_cropped_image(thresh1)

            self.operate_cropped_file(cropped_image)

            difference = None
            if ( prev_image is not None):
                difference =  cv2.absdiff(prev_image, thresh1)

            '''Label printing:'''
            if printing_label:

                cv2.rectangle(thresh1, (0,0) ,(700, 100),(255, 255, 0), cv2.FILLED)
                cv2.putText(thresh1,
                            "Callibrate threshold using W and S key untill your hand will have good contrast with background.",
                            (15, 15), cv2.FONT_HERSHEY_SIMPLEX, 0.35, (0, 0, 255), 1)
                cv2.putText(thresh1,
                            "Callibrate gausianBlur using E and D key untill your hand will have good contrast with background.",
                            (15, 25), cv2.FONT_HERSHEY_SIMPLEX, 0.35, (0, 0, 255), 1)
                cv2.putText(thresh1,
                            "Callibrate medianBlur using R and F key untill your hand will have good contrast with background.",
                            (15, 35), cv2.FONT_HERSHEY_SIMPLEX, 0.35, (0, 0, 255), 1)
                cv2.putText(thresh1,
                            "Use your mouse to specify hand gesture catching region",
                            (15, 45), cv2.FONT_HERSHEY_SIMPLEX, 0.35, (0, 0, 255), 1)
                cv2.putText(thresh1,
                            "WARNING: Select area with the greatest contrast beetween background and your hand",
                            (15, 55), cv2.FONT_HERSHEY_SIMPLEX, 0.35, (0, 0, 255), 1)
                cv2.putText(thresh1,
                            "When finished - press ENTER",
                            (15, 65), cv2.FONT_HERSHEY_SIMPLEX, 0.35, (0, 0, 255), 1)
                cv2.putText(thresh1,
                            "C - toggle label visibility",
                            (15, 75), cv2.FONT_HERSHEY_SIMPLEX, 0.35, (0, 0, 255), 1)
                cv2.putText(thresh1,
                            "Q - finish",
                            (15, 85), cv2.FONT_HERSHEY_SIMPLEX, 0.35, (0, 0, 255), 1)

            if ( len(mouse_drawing_rect_coords) == 2 ):
                cv2.rectangle(thresh1, mouse_drawing_rect_coords[0], mouse_drawing_rect_coords[1], (130, 255, 200), 2)

            cv2.imshow('Current frame', thresh1)

            '''if ( prev_image is not None ):
                cv2.imshow('Prevoius frame', prev_image)'''
            '''if ( difference is not None):
                cv2.imshow('Pixel Differences', difference)'''
            key_pressed = cv2.waitKey(10)

            if ( key_pressed == ord('w')):
                base_thresh_val += 1
            if (key_pressed == ord('s')):
                base_thresh_val -= 1
            if ( key_pressed == ord('e')):
                base_gaussian_val += 2
            if (key_pressed == ord('d')):
                if ( base_gaussian_val > 1 ):
                    base_gaussian_val -= 2
            if (key_pressed == ord('r')):
                base_med_val += 2
            if (key_pressed == ord('f')):
                if ( base_med_val > 1 ):
                    base_med_val -= 2
            if ( key_pressed == ord('c')):
                printing_label = not printing_label
            if ( key_pressed == ord('q') ):
                self.leave = True
            if ( key_pressed != -1):
                print(base_thresh_val)
                print(base_gaussian_val)
                print(base_med_val)
                print()

        '''Cleaning:'''
        cv2.destroyAllWindows()
        capture.release()
